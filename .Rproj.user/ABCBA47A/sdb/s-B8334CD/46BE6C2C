{
    "collab_server" : "",
    "contents" : "#####################\n#\n#####################\n\n#---\n# Install Necessary Resources\n#---\n  source('Functions.R')  \n  requiredPackages <- c('ZillowR',\n                        'readr',\n                        'tidyverse',\n                        'RSQLite',\n                        'DBI',\n                        'XML',\n                        'lubridate',\n                        'corrplot',\n                        'stringr',\n                        'car',\n                        'olsrr')\n  loadLibraries(requiredPackages)\n  rm(requiredPackages)\n\n  source('Functions.R')\n  source('zillowAPIcredentials.R')\n  # Remove source zillow credentials and insert your ZWSID below\n  # set_zillow_web_service_id(ZWSID)\n  #   rm(ZWSID)\n\n#---\n# Create a local database to store data\n#---\n  mydb <- dbConnect(RSQLite::SQLite(),\"my-db.sqlite\")\n  \n    \n#---\n# Create a list of addresses from Jefferson County Public Data\n#---\n  # http://data.lojic.org/\n  \n  jcky.addresses <- createResidentialAddressList('Jefferson_County_KY_Zoning.csv',\n                                                 'Jefferson_County_KY_Address_Points.csv')\n  # dbWriteTable(mydb, \"jckyaddresses\", jcky.addresses)  \n  \n  # Selecting a random list of 6k addresses. Given an API limit of 1k per day, this\n  # should cover the needs of an analysis due in 6 days.\n  jcky.tolookup <- jcky.addresses %>% sample_n(6000, replace=FALSE)\n  dbWriteTable(mydb, \"jckytolookup\", jcky.tolookup)\n  rm(jcky.addresses)\n\n#---\n# Create list of data for median house price per month\n#---\n  medianHousePrice.df <- read_csv(\"MSPNHSUS.csv\")\n   dbWriteTable(mydb,\"medianHousePrice\",medianHousePrice.df)\n#---\n# Download Zillow data from API\n#---\n  # Get 500 addresses from list of addresses and do a deep search on zillow\n  zillowSearch.df <- multipleDeepSearchZillow(jcky.tolookup,1000:1500)\n    dbWriteTable(mydb, \"zillowDeepSearch\",zillowSearch.df)\n  \n  # Unfortunately, the deep search doesn't include enough information.\n  # Also, many of these randomly selected properties are not in the Updated data \n  # because they have not been sold recently enought to be in Zillow database.\n  # However, most comps have been updated with full details, and comps have a bit\n  # more information themselves...so next step is to get comps, we should be able\n  # to get 25 per zpid and per API call...so let's do it.\n  zillowComps.df <- multipleDeepCompsZillow(zillowSearch.df$zpid,25)\n    # if total rooms is empty there is less likely to be Updated data...so remove those\n    zillowComps.df <- zillowComps.df %>% filter(is.na(totalRooms)==FALSE)\n    \n  \n  # It is possible these comps are duplicates. Need to fix that.\n  zillowComps.df <- zillowComps.df[duplicated(zillowComps.df$zpid)==FALSE,]\n    dbWriteTable(mydb, \"zillowDeepComps\",zillowComps.df)\n    \n  # Finally, what we really want is the Updated data because it is quite rich. API calls\n  # are limited so 500 of these should be a good number.\n  zillowUpdates <- multipleUpdatedPropertyDetails(zillowComps.df$zpid[1:500])\n    \n#---\n# Combine median house prices, zillow deep comps data and zillow update data, then clean results for analysis\n#---\n  zillowComps.keep.df <- zillowComps.df %>% select(zpid, \n                                                   taxAssessmentYear, \n                                                   taxAssessment,\n                                                   lastSoldDate,\n                                                   `last-updated`,\n                                                   percentile,\n                                                   zindexValue)\n  zillowUpdates.keep.df <- zillowUpdates %>% select(zpid,\n                                                    street,\n                                                    zipcode,\n                                                    city,\n                                                    state,\n                                                    numRooms,\n                                                    bedrooms,\n                                                    bathrooms,\n                                                    finishedSqFt,\n                                                    lotSizeSqFt,\n                                                    yearBuilt,\n                                                    coveredParkingSpaces,\n                                                    roof,\n                                                    exteriorMaterial,\n                                                    heatingSources,\n                                                    heatingSystem,\n                                                    coolingSystem,\n                                                    floorCovering,\n                                                    architecture,\n                                                    numFloors,\n                                                    basement,\n                                                    parkingType,\n                                                    coveredParkingSpaces)\n  zillowMerged.df <- left_join(zillowUpdates.keep.df,zillowComps.keep.df,by=\"zpid\")\n    rm(zillowComps.keep.df)\n    rm(zillowUpdates.keep.df)\n    zillowMerged.df$lastSoldDate <- mdy(zillowMerged.df$lastSoldDate)\n    zillowMerged.df$`last-updated` <- mdy(zillowMerged.df$`last-updated`)  \n    zillowMerged.df <- zillowMerged.df[is.na(zillowMerged.df$taxAssessmentYear)==FALSE,]\n    zillowMerged.df <- zillowMerged.df[is.na(zillowMerged.df$lastSoldDate)==FALSE,]\n    \n  zillowMerged.df <- zillowMerged.df %>% rowwise() %>% mutate(natAvgAssessYear = getYearAvgFromMonthly(medianHousePrice.df,taxAssessmentYear))\n  zillowMerged.df <- ungroup(zillowMerged.df)\n  zillowMerged.df <- zillowMerged.df %>% rowwise() %>% mutate(natAvgLastSoldYear = getMedianFromDate(medianHousePrice.df,lastSoldDate))\n    zillowMerged.df <- zillowMerged.df[zillowMerged.df$natAvgLastSoldYear != 0,]                                  \n  \n#---\n# Create regression model\n#---\n  #-\n  # Create temp variable to protect raw data, cleanup temp\n  #-\n    zillowMerged.int.df <- zillowMerged.df\n    # remove , from zindexValue number\n    zillowMerged.int.df$zindexValue <- str_replace(zillowMerged.int.df$zindexValue,\",\",\"\")\n    # convert numberic columns to numeric\n    for(i in c(6:11,23:30)) {\n      zillowMerged.int.df[,i] <- as.data.frame(lapply(zillowMerged.int.df[,i],as.numeric),stringsAsFactors = FALSE)\n    }\n  \n  #-\n  # Review Data to determine good variables\n  #-\n    zillow.cor <- cor(na.omit(select(zillowMerged.int.df)),6:11,23:30) \n    corrplot(zillow.cor)\n    scatterplot(zillowMerged.int.df$lotSizeSqFt, zillowMerged.int.df$taxAssessment)\n    \n    zillow.model <- lm(zindexValue ~ finishedSqFt + numRooms + bedrooms + bathrooms + lotSizeSqFt + zipcode + parkingType + basement + exteriorMaterial + taxAssessment, data=zillowMerged.int.df)\n    summary(zillow.model)\n    confint(zillow.model)\n    residualPlot(zillow.model)\n    influenceIndexPlot(zillow.model)\n    #check for colinearity problems > 10\n    vif(zillow.model) \n   \n  #-\n  # Scale Data\n  #-\n    \n  #-\n  # Transforming Data\n  #-\n    \n  #-\n  # Using stepAIC to predict which variables to use in model\n  #-\n    AIC <- ols_stepaic_forward(zillow.model,details=TRUE)\n    AIC\n  \n  #-\n  # Try an adjusted model based on AIC\n  #-\n    zillow.model <- lm(zindexValue ~ bedrooms + bathrooms + lotSizeSqFt + zipcode, data=zillowMerged.int.df)\n    summary(zillow.model)\n    confint(zillow.model)\n    residualPlot(zillow.model)\n    influenceIndexPlot(zillow.model)\n    #check for colinearity problems > 10\n    vif(zillow.model)\n    ",
    "created" : 1508705713391.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2459101954",
    "id" : "46BE6C2C",
    "lastKnownWriteTime" : 1508715942,
    "last_content_update" : 1508716232615,
    "path" : "~/MSA/Fall 2017/ZillowAnalysis/ZillowAnalysis.R",
    "project_path" : "ZillowAnalysis.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}